{"version":3,"sources":["mega-api/util.js","mega-api/crypto.js","mega-api/mega-util.js","mega-api/mega-api.js","mega-api/grouped-tasks.js","mega-api/synchronization.js","mega-api/file-attributes.js","mega-api/share.js","mega-api/nodes.js","mega-api/mega.js"],"names":["Util","[object Object]","base64","atob","e","console","error","binaryString","btoa","arrayBuffer","TextDecoder","decode","reduce","accumulator","byte","String","fromCharCode","u8Array","Uint8Array","length","i","charCodeAt","base64ToBinaryString","binaryStringToArrayBuffer","arrayBufferToBinaryString","binaryStringToBase64","byteToHex","ByteToHexTable","get","buffer","hexOctets","Array","join","self","inited","init","hexOctet","toString","padStart","push","result","previousValue","currentValue","index","Number","MAX_SAFE_INTEGER","seconds","date","Date","pad","str","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","bytes","decimals","Math","floor","log","parseFloat","pow","toFixed","ms","inNextEventLoopTask","nextEventLoopTask","Promise","resolve","setTimeout","setImmediate","url","searchParams","Object","entries","forEach","key","value","append","executable","count","delay","sleep","name","includes","replace","array1","array2","string","mode","unescape","encodeURIComponent","TextEncoder","encode","arrayBufferToBase64","decodeURIComponent","escape","base64ToArrayBuffer","stream","reader","getReader","done","read","globalThis","port1","port2","MessageChannel","queue","onmessage","shift","callback","postMessage","object","message","data","Crypto","iv","padding","_arrayBufferToWordArray4","trunc","view","DataView","byteOffset","byteLength","words","getInt32","CryptoJS","lib","WordArray","create","_data","_key","_iv","wordArray","sigBytes","ArrayBuffer","setInt32","_wordArrayToArrayBuffer2","AES","decrypt","ciphertext","MegaUtil","attributesEncoded","nodeKey","attributesEncrypted","megaBase64ToArrayBuffer","attributesArrayBuffer","decryptAES","trimmedAttributesPlaneString","arrayBufferToUtf8String","substring","n","c","serializedFingerprint","JSON","parse","fingerprintBytes","fileChecksum","subarray","timeBytesLength","timeBytes","modificationDate","arrayBufferToLong","decryptedKey","metaMac","encryptedKey","block","decryptedBlock","set","megaBase64EncodedStr","paddingLength","_getPaddingLengthForMegaBase64","repeat","megaBase64","megaBase64ToBase64","base64EncodedStr","base64ToMegaBase64","k","MegaApi","errorRepeatCount","errorRepeatDelay","repeatIfErrorAsync","Semaphore","GroupedTasks","entriesHolder","pull","payloads","entry","getValue","responseArray","requestApiSafe","RequestApiGrouped","payload","grouped","_url","URL","apiGateway","addSearchParamsToURL","requestApiGrouped","getResult","semaphore","acquire","response","_","requestApiUnsafe","apiErrorHandler","release","fetch","method","body","stringify","referrerPolicy","status","Error","text","isArray","id","type","requestApi","a","fah","ssl","r","ids","selectedIdsBinary","responseBytes","async","headers","connection","shareId","responseData","p","g","prettyResponse","size","nodeAttributesEncoded","downloadUrl","timeLeft","EFQ","MSD","fileAttributesStr","ca","f","rawNodes","sn","noc","shareRootNodeId","firstNode","match","warn","_getShareRootNodeId","_prettifyType","_parseKeyFromNode","node","decryptionKeyStr","nodes","map","prettyNode","parentId","ownerId","attributes","creationDate","_prettifyNodes","rootId","EntriesHolder","entryKey","firstEntry","groupedTasks","this","first","pullEntries","pullParts","entryClass","delayStrategy","SimpleEntry","execute","afterDelayWithMicroTask","reject","Map","needHandle","enqueue","getKey","has","handle","catch","array","delete","pos","slice","then","limit","time","isDisabled","completed","completeTimes","active","performance","now","pending","_release","_limit","_delay","releaseAll","max","disable","CountDownLatch","_count","_promise","_resolve","released","CountUpAndDownLatch","synchronization","FileAttribute","bunch","Bunch","of","cached","Types","hasBytes","getDownloadUrl","values","_bunch","fileAttribute","hasDownloadUrl","requestFileAttributeDownloadUrl","Boolean","preview","thumbnail","FileAttributeBytes","DlUrlRequests","RequestDlUrlEntry","_fileAttribute","FileAttributes","byType","dlUrlRequests","parts","sync","handlePart","fileAttributeId","fileAttrIDs","keys","generator","fileAttributeBytes","dataBytes","resolvers","DlBytesRequests","_downloadUrl","dlBytesRequests","requestFileAttributeBytes","parseBytes","offset","idBytes","lengthBytes","arrayBufferToMegaBase64","fileAttributes","encryptedBytes","_fileAttributes","_encryptedBytes","getEncryptedBytes","strictMode","split","chunk","groups","find","att","add","getAttribute","Thumbnail","Preview","typeClass","getBytes","Share","shareParts","assign","isFolder","selectedFolderId","selectedFileId","getUrl","fromUrl","selectedId","regExp","folder","file","oldFormat","prefixes","selected","BasicFolderShareNode","Symbol","toStringTag","masterKey","parent","decryptionKeyEncrypted","_decryptionKey","decryptKey","path","root","FileNode","super","parseEncodedNodeAttributes","parseFingerprint","getEncryptedName","_keyParts","decryptionKeyToParts","mtime","modificationDateFormatted","secondsToFormattedString","MediaFileNode","getThumbnail","getPreview","FolderNode","_size","RootFolderNode","SharedFileNode","share","nodeInfo","decryptionKey","_meta","SharedMediaFileNode","Nodes","getFolderNodes","getSharedNode","requestNodeInfo","requestFolderInfo","folders","files","resultNode","resultArray","defineProperty","hasSerializedFingerprint","encryptedName"],"mappings":"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","sourcesContent":["import {atob, btoa, MessageChannel} from \"./browser-context.js\";\n\nexport default class Util {\n\n    /**\n     * @param {string} base64\n     * @returns {string} binaryString\n     */\n    static base64ToBinaryString(base64) {\n        try {\n            return atob(base64);\n        } catch (e) {\n            console.error(\"Incorrect Base64:\", base64);\n            throw e;\n        }\n    }\n\n    /**\n     * @param {string} binaryString\n     * @returns {string} base64\n     */\n    static binaryStringToBase64(binaryString) {\n        return btoa(binaryString);\n    }\n\n    /**\n     * @param {TypedArray|ArrayBuffer|DataView} arrayBuffer\n     * @returns {string}\n     */\n    static arrayBufferToUtf8String(arrayBuffer) {\n        return new TextDecoder().decode(arrayBuffer);\n    }\n\n    /**\n     * To binary string (Latin1).\n     *\n     * NB: A binary string is a string is encoded with \"Latin1\" (\"ISO-8859-1\", not \"Windows−1252\"!).\n     * `TextDecoder` does not support decoding \"Latin1\", \"ISO-8859-1\".\n     * ```\n     * const str = new TextDecoder(\"ISO-8859-1\").decode(new Uint8Array([148, 125, 1, 218, 233, 169, 248, 111]));\n     * console.log(str[0], str[0].charCodeAt(0)); // \"”\" 8221 (!)\n     * const result = Uint8Array.from(str.split(\"\"), ch => ch.charCodeAt(0));\n     * console.log(result);\n     * // [29, 125, 1, 218, 233, 169, 248, 111] // 29 (!) (trims `8221` to one byte)\n     * ```\n     * UPD:\n     * Well, it works not so good as I expected\n     * ```\n     * String.fromCharCode(...new Uint8Array(125830)) // OK\n     * String.fromCharCode(...new Uint8Array(125831)) // RangeError: Maximum call stack size exceeded\n     * ```\n     * Replaced with `reduce`. It works OK, no need to optimise (like `Util.arrayBufferToHexString()`).\n     *\n     * Also:\n     * new TextDecoder(\"utf-8\").decode(new Uint8Array([128])).charCodeAt(0) === 65533 \"�\"\n     * new TextDecoder(\"Latin1\").decode(new Uint8Array([128])).charCodeAt(0) === 8364 \"€\"\n     * String.fromCharCode(128).charCodeAt(0) === 128 \"\"\n     *\n     * @param {Uint8Array} arrayBuffer\n     * @returns {string} binaryString\n     * */\n    static arrayBufferToBinaryString(arrayBuffer) {\n        return arrayBuffer.reduce((accumulator, byte) => accumulator + String.fromCharCode(byte), \"\");\n    }\n\n    /**\n     * Do not use `new TextEncoder().encode(binaryStr)` for binary (Latin1) strings.\n     * It maps code points to utf8 bytes (so char codes of 128-255 range maps to 2 bytes, not 1).\n     * For example: String.fromCharCode(128) is mapped to [194, 128] bytes\n     *\n     * The current implementation works x2-4 times faster than:\n     * `Uint8Array.from(binaryString.split(\"\"), ch => ch.charCodeAt(0))`\n     *\n     * @param {string} binaryString\n     * @returns {Uint8Array} u8Array\n     */\n    static binaryStringToArrayBuffer(binaryString) {\n        const u8Array = new Uint8Array(binaryString.length);\n        for (let i = 0; i < binaryString.length; i++) {\n            u8Array[i] = binaryString.charCodeAt(i);\n        }\n        return u8Array;\n    }\n\n    /**\n     * Binary string (Latin1) encoded with Base64 to ArrayBuffer\n     * @param {string} base64\n     * @returns {Uint8Array}\n     */\n    static base64ToArrayBuffer(base64) {\n        const binaryString = Util.base64ToBinaryString(base64);\n        return Util.binaryStringToArrayBuffer(binaryString);\n    }\n\n    /**\n     * ArrayBuffer to Base64 encoded binary string (Latin1)\n     * @param {Uint8Array} arrayBuffer\n     * @returns {string}\n     */\n    static arrayBufferToBase64(arrayBuffer) {\n        const binaryString = Util.arrayBufferToBinaryString(arrayBuffer);\n        return Util.binaryStringToBase64(binaryString);\n    }\n\n    /**\n     * The optimised version\n     * @param {TypedArray} arrayBuffer\n     * @returns {string}\n     */\n    static arrayBufferToHexString(arrayBuffer) {\n        const byteToHex = Util.ByteToHexTable.get();\n\n        const buffer = new Uint8Array(arrayBuffer.buffer);\n        const hexOctets = new Array(buffer.length);\n\n        for (let i = 0; i < buffer.length; i++) {\n            hexOctets[i] = byteToHex[buffer[i]];\n        }\n\n        return hexOctets.join(\"\");\n    }\n\n    /**\n     * Allows to get the precomputed hex octets table (the array)\n     *\n     * `[0]: \"00\"`\n     * ...\n     * `[255]: \"FF\"`\n     *\n     * It is used only in `Util.arrayBufferToHexString()`. Lazy loading.\n     * @private\n     */\n    static ByteToHexTable = class {\n        static get() {\n            const self = Util.ByteToHexTable;\n            if (!self.inited) {\n                self.init();\n            }\n            return self.byteToHex;\n        }\n        static byteToHex = [];\n        static inited = false;\n        static init = () => {\n            const self = Util.ByteToHexTable;\n            for (let i = 0; i < 256; i++) {\n                const hexOctet = i.toString(16).padStart(2, \"0\");\n                self.byteToHex.push(hexOctet);\n            }\n            self.inited = true;\n        }\n    }\n\n\n\n    /**\n     * Array of bytes (Little-endian) to Long (64-bits) value\n     * @param {Uint8Array} arrayBuffer\n     * @returns {number}\n     */\n    static arrayBufferToLong(arrayBuffer) {\n        const sizeofLong = 8; // in fact max integer value in JS has 7 bytes, see Number.MAX_SAFE_INTEGER\n\n        if (arrayBuffer.length > sizeofLong) {\n            throw \"Length is over size of Long\";\n        }\n\n        const result = arrayBuffer.reduce((previousValue, currentValue, index) => {\n            return previousValue + currentValue * (256 ** index);\n        }, 0);\n\n        if (result > Number.MAX_SAFE_INTEGER) { // > 9007199254740991 === 00 1F FF FF  FF FF FF FF\n            throw \"Over Number.MAX_SAFE_INTEGER\";\n        }\n\n        return result;\n    }\n\n    /**\n     * 1436853891 -> \"2015.07.14 09:04:51\"\n     * @param {number} seconds\n     * @returns {string}\n     */\n    static secondsToFormattedString(seconds) {\n        const date = new Date(seconds * 1000);\n\n        // Adds zero padding\n        function pad(str) {\n            return str.toString().padStart(2, \"0\");\n        }\n\n        return date.getFullYear() + \".\" + pad(date.getMonth() + 1) + \".\" + pad(date.getDate()) + \" \" +\n            pad(date.getHours()) + \":\" + pad(date.getMinutes()) + \":\" + pad(date.getSeconds());\n    }\n\n    /**\n     * Format bytes to human readable format\n     * Trims the tailing zeros\n     *\n     * {@link https://stackoverflow.com/a/18650828/11468937}\n     * @see MegaUtil.bytesToSize\n     * @param {number} bytes\n     * @param {number} [decimals=2]\n     * @returns {string}\n     */\n    static bytesToSize(bytes, decimals = 2) {\n        if (bytes === 0) {\n            return \"0 B\";\n        }\n        const k = 1024;\n        decimals = decimals < 0 ? 0 : decimals;\n        const sizes = [\"B\", \"KB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\", \"ZB\", \"YB\"];\n\n        const i = Math.floor(Math.log(bytes) / Math.log(k));\n        return Number.parseFloat((bytes / Math.pow(k, i)).toFixed(decimals)) + \" \" + sizes[i];\n    }\n\n    /**\n     * @example\n     * await Util.sleep(50);\n     *\n     * @param {number} ms milliseconds\n     * @param {boolean} inNextEventLoopTask - if passed 0 wait for the next event loop task, or no (use micro task)\n     * @returns {Promise}\n     */\n    static sleep(ms, inNextEventLoopTask = false) {  //todo rework (true be default)\n        if (ms <= 0) {\n            if (inNextEventLoopTask) {\n                return Util.nextEventLoopTask();\n            } else {\n                return Promise.resolve(); // It's not the same thing as using `setImmediate`\n            }\n        }\n        return new Promise(resolve => setTimeout(resolve, ms));\n    }\n\n    /**\n     * Return a promise that fulfills at the next event loop task\n     * Use to split a long time work to multiple tasks\n     *\n     * @example\n     * doWorkPart1();\n     * await Util.nextEventLoopTask();\n     * doWorkPart2();\n     *\n     * @returns {Promise}\n     */\n    static nextEventLoopTask() {\n        return new Promise(resolve => {\n            Util.setImmediate(resolve);\n        });\n    }\n\n    /**\n     * Transforms an object like this: `{\"n\": \"e1ogxQ7T\"}` to `\"n=e1ogxQ7T\"`\n     * and adds it to the url as search params. The example result: `${url}?n=e1ogxQ7T`.\n     *\n     * @param {URL} url\n     * @param {Object} searchParams\n     */\n    static addSearchParamsToURL(url, searchParams) {\n        Object.entries(searchParams).forEach(([key, value]) => {\n            url.searchParams.append(key, value.toString());\n        });\n    }\n\n    /**\n     * @param {function} executable - an async function to repeat if it throws an exception\n     * @param {number} count=5 - count of the repeats\n     * @param {number} delay=5000 - ms to wait before repeating\n     * @return {Promise<*>}\n     */\n    static async repeatIfErrorAsync(executable, count = 5, delay = 5000) { //todo make `delay` iterable\n        for (let i = 0;; i++) {\n            try {\n                if (i) {\n                    console.log(\"REPEAT\");\n                }\n                return await executable();\n            } catch (e) {\n                console.error(e, `ERROR! Will be repeated. The try ${i + 1} of ${count}.`);\n                if (i < count) {\n                    await Util.sleep(delay);\n                } else {\n                    throw e;\n                }\n            }\n        }\n    }\n\n    /**\n     * @param {string} name\n     * @return {string}\n     */\n    static getSafeName(name) {\n        //todo implement this:\n        // https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file\n        if (name.includes(\"/\")) {\n            console.log(`Bad filename: \"${name}\"`); // for debugging currently\n        }\n        return name.replace(\"/\", \"_\");\n    }\n    //todo isSafeName() - the similar method\n\n    /**\n     * The simple implementation\n     * @param {Array|TypedArray} array1\n     * @param {Array|TypedArray} array2\n     * @return {boolean}\n     */\n    static compareArrays(array1, array2) {\n        if (array1.length === array2.length) {\n            for (let i = 0; i < array1.length; i++) {\n                if (array1[i] !== array2[i]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Convert the string to the base64 encoded utf-8 bytes.\n     *\n     * With default mode \"default\" it uses `unescape` function that is deprecated now,\n     * but it works much faster than converting with \"safe\" mode (ArrayBuffer -> binaryString -> base64).\n     * With \"unsafe\" mode the sting must be Latin1 encoded, or you get the exception in a browser\n     * (\"DOMException: Failed to execute 'btoa' on 'Window':\n     *     the string to be encoded contains characters outside of the Latin1 range.\") or the wrong result in Node.js.\n     *\n     * For node.js you can use:\n     * `Buffer.from(string).toString(\"base64\")`\n     *\n     * @param {string} string\n     * @param {\"default\"|\"safe\"|\"unsafe\"} [mode=\"default\"]\n     * @returns {string} base64\n     */\n    static stringToBase64(string, mode = \"default\") {\n        if (mode === \"default\") {       // uses deprecated `escape` function\n            const binaryString = unescape(encodeURIComponent(string));\n            return Util.binaryStringToBase64(binaryString);\n        } else if (mode === \"safe\") {   // works slower (~3x)\n            const arrayBuffer = new TextEncoder().encode(string);\n            return Util.arrayBufferToBase64(arrayBuffer);\n        } else if (mode === \"unsafe\") { // only for Latin1 within Base64\n            return Util.binaryStringToBase64(string);\n        }\n    }\n\n    /**\n     * Convert the Base64 encoded string of utf-8 bytes to the string.\n     *\n     * @param {string} base64\n     * @param {\"default\"|\"safe\"|\"unsafe\"} [mode=\"default\"]\n     * @returns {string}\n     */\n    static base64ToString(base64, mode = \"default\") {\n        if (mode === \"default\") {       // uses deprecated `escape` function\n            const binaryString = Util.base64ToBinaryString(base64);\n            return decodeURIComponent(escape(binaryString));\n        } else if (mode === \"safe\") {   // works slower (~x4+)\n            const arrayBuffer = Util.base64ToArrayBuffer(base64);\n            return new TextDecoder().decode(arrayBuffer);\n        } else if (mode === \"unsafe\") { // only for Latin1 within Base64\n            return Util.base64ToBinaryString(base64);\n        }\n    }\n\n    /**\n     * Make ReadableStream iterable\n     *\n     * @example\n     *  for await (const chunk of iterateReadableStream(stream)) {\n     *      i++;                 // If you do not want to block event loop.\n     *      if (i % 128 === 0) { // Note: it has negative impact for performance: ~7 %, without `if`: ~30 %.\n     *          await new Promise(resolve => setImmediate(resolve));\n     *      }\n     *      handle(chunk);\n     * }\n     *\n     * @template T\n     * @param {ReadableStream<T>} stream\n     * @returns {AsyncGenerator<T>}\n     */\n    static async * iterateReadableStream(stream) {\n        const reader = stream.getReader();\n        while (true) {\n            const {done, value} = await reader.read();\n            if (done) {\n                break;\n            }\n            yield value;\n        }\n    }\n\n\n    /**\n     * Browsers' MessagePort has no `unref`/`ref`,\n     * but the realization for Node requires to use them so let's just use `globalThis.setImmediate`.\n     */\n    static setImmediate = globalThis.setImmediate ||\n        /*#__PURE__*/ (function() {\n            const {port1, port2} = new MessageChannel();\n            const queue = [];\n\n            port1.onmessage = function() {\n                const callback = queue.shift();\n                callback();\n                // if (!queue.length) {\n                //     port1.unref();\n                // }\n            };\n            // port1.unref();\n\n            return function(callback) {\n                // port1.ref();\n                port2.postMessage(null);\n                queue.push(callback);\n            };\n        })();\n\n\n    // https://developers.google.com/web/updates/2011/09/Workers-ArrayBuffer\n    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm\n    static structuredClone(object) {\n        return new Promise(resolve => {\n            const {port1, port2} = new MessageChannel();\n            port1.onmessage = function(message) {\n                resolve(message.data);\n            };\n            port2.postMessage(object);\n        });\n    }\n\n    // // the experimental version\n    // static logger = {\n    //     DEBUG: true,\n    //     INFO: true,\n    //     /**\n    //      * @param {*} arguments\n    //      */\n    //     debug() {\n    //         if (!Util.logger.DEBUG) {\n    //             return;\n    //         }\n    //         // rollup says: \"A static class field initializer may not contain arguments\"\n    //         [...arguments].forEach(el => {\n    //             console.log(el);\n    //         });\n    //         console.log();\n    //     },\n    //     /**\n    //      * @param {*} arguments\n    //      */\n    //     info() {\n    //         if (!Util.logger.INFO) {\n    //             return;\n    //         }\n    //         // rollup says: \"A static class field initializer may not contain arguments\"\n    //         [...arguments].forEach(el => {\n    //             console.log(el);\n    //         });\n    //     }\n    // };\n}","// import {default as CryptoJS} from \"crypto-es\";      // or\n// import CryptoJS from \"./dependencies/crypto-es.js\"; // or\nimport {CryptoJS} from \"./dependencies/all.js\";\n\nexport default class Crypto {\n    /**\n     * Decrypt AES with `CryptoJS` (Upd: CryptoES)\n     *\n     * Modes: \"CBC\" (the default), \"CFB\", \"CTR\", \"OFB\", \"ECB\".\n     *\n     * Padding schemes: \"Pkcs7\" (the default), \"ZeroPadding\", \"NoPadding\", \"Iso97971\", \"AnsiX923\", \"Iso10126\".\n     *\n     * Default IV is zero filled ArrayBuffer.\n     *\n     * @param {Uint8Array} data\n     * @param {Uint8Array} key\n     * @param {Object} [config]\n     * @param {Uint8Array} [config.iv]\n     * @param {\"CBC\"|\"CFB\"|\"CTR\"|\"OFB\",|\"ECB\"} [config.mode=\"CBC\"]\n     * @param {\"Pkcs7\"|\"ZeroPadding\"|\"NoPadding\"|\"Iso97971\"|\"AnsiX923\"|\"Iso10126\"} [config.padding=\"Pkcs7\"]\n     * @returns {Uint8Array}\n     */\n    static decryptAES(data, key, {iv, mode, padding} = {}) {\n\n        /** Default parameters initialization */\n        iv = iv || new Uint8Array(key.length);\n        mode = mode || \"CBC\";\n        padding = padding || \"Pkcs7\";\n\n        /**\n         * The convert code [*] is from \"crypto-js/lib-typedarrays.js\" file\n         * Note: a \"word\" is a 32 bits big-endian signed integer\n         *\n         * @param {Uint8Array} u8Array // todo use \"u8Array\" name in other files\n         * @returns {CryptoES.lib.WordArray} wordArray\n         * @private\n         */\n        const _arrayBufferToWordArray = function(u8Array) { // todo: remove in the next commit\n            const length = Math.trunc(u8Array.length / 4) + (u8Array.length % 4 ? 1 : 0); // \"round up\" // todo Math.ceil\n            const words = new Array(length);\n            for (let i = 0; i < u8Array.length; i++) {\n                words[i >>> 2] |= u8Array[i] << (24 - (i % 4) * 8); // [*]\n            }\n            return CryptoJS.lib.WordArray.create(words, u8Array.length); // the passing ArrayBuffer works only with CryptoES, not CryptoJS\n        };\n\n        /**\n         * Works more than x3-8 faster! but dependent of the endianness. only little-endian.\n         * @param {Uint8Array} u8Array\n         */\n        const _arrayBufferToWordArray2 = function(u8Array) { // todo: remove in the next commit\n            const length = Math.trunc(u8Array.length / 4) + (u8Array.length % 4 ? 1 : 0);\n            // Note: Uint8Array may be a presentation just of a part of the buffer [!]\n            const u32array = new Int32Array(u8Array.buffer, u8Array.byteOffset, length);\n            const words = new Array(u32array.length);\n            for (let i = 0; i < words.length; i++) { // 255 === 0b00000000_00000000_00000000_11111111\n                words[i] = ((u32array[i] >> 0 & 255) << 24) | ((u32array[i] >> 8 & 255) << 16) | ((u32array[i] >> 16 & 255) << 8) | ((u32array[i] >> 24 & 255) << 0);\n            }\n            return CryptoJS.lib.WordArray.create(words, u8Array.length);\n        };\n\n        /**\n         * A bit slower than v2 (~10 %), but independent of the endianness\n         * @param {Uint8Array} u8Array\n         */\n        const _arrayBufferToWordArray3 = function(u8Array) { // todo: remove in the next commit\n            const length = Math.trunc(u8Array.length / 4) + (u8Array.length % 4 ? 1 : 0);\n            const words = new Array(length);\n            for (let i = 0; i < length; i++) {\n                words[i] = (u8Array[i*4] << 24) | (u8Array[i*4+1] << 16) | (u8Array[i*4+2] << 8) | (u8Array[i*4+3] << 0);\n            }\n            return CryptoJS.lib.WordArray.create(words, u8Array.length);\n        };\n\n\n        /**\n         * THE BEST\n         *\n         * Faster 5-9 times than old one. (x5 for zeros, x9+ for random values)\n         *\n         * Endianness independent.\n         * @param {Uint8Array} u8Array\n         */\n        const _arrayBufferToWordArray4 = function(u8Array) {\n            const length = Math.trunc(u8Array.length / 4) + (u8Array.length % 4 ? 1 : 0);\n            const view = new DataView(u8Array.buffer, u8Array.byteOffset, u8Array.byteLength);\n            const words = new Array(length);\n            for (let i = 0; i < length; i++) {\n                words[i] = view.getInt32(i * 4, false);\n            }\n            return CryptoJS.lib.WordArray.create(words, u8Array.byteLength);\n        };\n\n        const _data = _arrayBufferToWordArray4(data);\n        const _key = _arrayBufferToWordArray4(key);\n        const _iv = _arrayBufferToWordArray4(iv);\n        const plaintextWA = CryptoJS.AES.decrypt( /* (CipherParamsData, WordArray, IBlockCipherCfg) (for CryptoJS) */\n            {\n                ciphertext: _data\n            },\n            _key,\n            {\n                iv: _iv,\n                mode: CryptoJS.mode[mode],\n                padding: CryptoJS.pad[padding]\n            }\n        );\n\n        /**\n         * The convert code [*] is from CryptoJS.enc.Latin1.stringify (\"crypto-js/core.js\")\n         * See CryptoJS.enc.Latin1 stringify()\n         * Note: \"word\" is a 32 bits big-endian signed integer\n         *\n         * @param {CryptoES.lib.WordArray} wordArray\n         * @returns {Uint8Array}\n         * @private\n         */\n        const _wordArrayToArrayBuffer = function(wordArray) { // todo: remove in the next commit\n            const u8Array = new Uint8Array(wordArray.sigBytes);\n            for (let i = 0; i < wordArray.sigBytes; i++) {\n                u8Array[i] = (wordArray.words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff; // [*]\n            }\n            return u8Array;\n        };\n        // THE BEST: 4 times faster\n        const _wordArrayToArrayBuffer2 = function(wordArray) {\n            const {words, sigBytes} = wordArray;\n            const arrayBuffer = new ArrayBuffer(words.length * 4);\n            const view = new DataView(arrayBuffer);\n            for (let i = 0; i < words.length; i++) {\n                view.setInt32(i * 4, words[i], false);\n            }\n            return new Uint8Array(arrayBuffer, 0, sigBytes);\n        };\n\n        return _wordArrayToArrayBuffer2(plaintextWA);\n    }\n}","import Util from \"./util.js\";\nimport Crypto from \"./crypto.js\";\n\n/**\n * The class contains Mega specific static util methods.\n */\nexport default class MegaUtil {\n\n    /**\n     * @param {string} attributesEncoded\n     * @param {Uint8Array} nodeKey\n     * @returns {{name: string, serializedFingerprint: string}}\n     */\n    static parseEncodedNodeAttributes(attributesEncoded, nodeKey) {\n        const attributesEncrypted   = MegaUtil.megaBase64ToArrayBuffer(attributesEncoded);\n        const attributesArrayBuffer = Crypto.decryptAES(attributesEncrypted, nodeKey, {padding: \"ZeroPadding\"});\n        const attributesPlane       = Util.arrayBufferToUtf8String(attributesArrayBuffer);\n\n        const trimmedAttributesPlaneString = attributesPlane.substring(\"MEGA\".length);\n        const {\n            n: name,\n            c: serializedFingerprint // Only for files (not folders)\n        } = JSON.parse(trimmedAttributesPlaneString);\n\n        return {name, serializedFingerprint};\n    }\n\n    /**\n     * @param {string} serializedFingerprint\n     * @returns {{modificationDate: number, fileChecksum: Uint8Array}}\n     */\n    static parseFingerprint(serializedFingerprint) {\n        const fingerprintBytes = MegaUtil.megaBase64ToArrayBuffer(serializedFingerprint);\n\n        const fileChecksum    = fingerprintBytes.subarray(0, 16); // 4 CRC32 of the file [unused]\n        const timeBytesLength = fingerprintBytes[16];             // === 4, and 5 after 2106.02.07 (06:28:15 UTC on Sunday, 7 February 2106)\n        const timeBytes       = fingerprintBytes.subarray(17, 17 + timeBytesLength); // in fact, after this no data is\n\n        // I don't think that it is necessary, but let it be\n        if (timeBytesLength > 5) {\n            throw \"Invalid value: timeBytesLength = \" + timeBytesLength;\n        }\n\n        const modificationDate = Util.arrayBufferToLong(timeBytes);\n\n        return {modificationDate, fileChecksum};\n    }\n\n    /**\n     * {@link https://github.com/gpailler/MegaApiClient/blob/93552a027cf7502292088f0ab25f45eb29ebdc64/MegaApiClient/Cryptography/Crypto.cs#L63}\n     * @param {Uint8Array} decryptedKey\n     * @returns {{iv: Uint8Array, metaMac: Uint8Array, key: Uint8Array}}\n     */\n    static decryptionKeyToParts(decryptedKey) {\n        const iv      = decryptedKey.subarray(16, 24);\n        const metaMac = decryptedKey.subarray(24, 32);\n        const key     = new Uint8Array(16);\n\n        // 256 bits -> 128 bits\n        for (let i = 0; i < 16; i++) {\n            key[i] = decryptedKey[i] ^ decryptedKey[i + 16];\n        }\n\n        return {iv, metaMac, key};\n    }\n\n    /**\n     * {@link https://github.com/gpailler/MegaApiClient/blob/93552a027cf7502292088f0ab25f45eb29ebdc64/MegaApiClient/Cryptography/Crypto.cs#L33}\n     * @param {Uint8Array} encryptedKey a key that need to decrypt\n     * @param {Uint8Array} key a key to decrypt with it\n     * @returns {Uint8Array} decryptionKey\n     */\n    static decryptKey(encryptedKey, key) {\n        const result = new Uint8Array(encryptedKey.length);\n\n        for (let i = 0; i < encryptedKey.length; i += 16) {\n            const block = encryptedKey.subarray(i, i + 16);\n            const decryptedBlock = Crypto.decryptAES(block, key, {padding: \"NoPadding\"}); // \"NoPadding\" – for the case when the last byte is zero (do not trim it)\n            result.set(decryptedBlock, i);\n        }\n\n        return result;\n    }\n\n    // ----------------------------------------------------------------\n\n    /**\n     * Transform Mega Base64 format to normal Base64\n     *   \"AWJuto8_fhleAI2WG0RvACtKkL_s9tAtvBXXDUp2bQk\"\n     *   ->\n     *   \"AWJuto8/fhleAI2WG0RvACtKkL/s9tAtvBXXDUp2bQk=\"\n     * @param {string} megaBase64EncodedStr\n     * @returns {string}\n     */\n    static megaBase64ToBase64(megaBase64EncodedStr) {\n        /** @param {string} megaBase64EncodedStr\n         *  @returns {number}\n         *  @private  */\n        function _getPaddingLengthForMegaBase64(megaBase64EncodedStr) {\n            /**\n             * Base64 padding's length is \"1\", \"2\" or \"0\" because of the \"block\" size has at least \"2\" chars.\n             * So a string's length is multiple of \"4\".\n             * Check the tables:\n             *     https://en.wikipedia.org/wiki/Base64#Examples\n             */\n            try {\n                \n           \n            const paddingLength = (4 - megaBase64EncodedStr.length % 4) % 4;\n            if (paddingLength === 3) {\n                throw {name: \"IllegalArgumentException\", message: \"Wrong Mega Base64 string\"};\n            }\n            return paddingLength;\n            } catch (error) {\n                return 100\n            }\n        }\n\n        const paddingLength = _getPaddingLengthForMegaBase64(megaBase64EncodedStr);\n        const result = megaBase64EncodedStr + \"=\".repeat(paddingLength);\n        return result.replace(/-/g, \"+\")\n                     .replace(/_/g, \"/\");\n    }\n\n    /**\n     * @param {string} megaBase64\n     * @returns {Uint8Array}\n     */\n    static megaBase64ToArrayBuffer(megaBase64) {\n        const base64 = MegaUtil.megaBase64ToBase64(megaBase64);\n        return Util.base64ToArrayBuffer(base64);\n    }\n\n    /**\n     * @param {string} base64EncodedStr\n     * @return {string}\n     */\n    static base64ToMegaBase64(base64EncodedStr) {\n        return base64EncodedStr.replace(/=/g,  \"\")\n                               .replace(/\\+/g, \"-\")\n                               .replace(/\\//g, \"_\");\n    }\n\n    /**\n     * @param {Uint8Array} arrayBuffer\n     * @return {string}\n     */\n    static arrayBufferToMegaBase64(arrayBuffer) {\n        const binaryString = Util.arrayBufferToBinaryString(arrayBuffer);\n        const base64 = Util.binaryStringToBase64(binaryString);\n        return MegaUtil.base64ToMegaBase64(base64);\n    }\n\n    /**\n     * @param {string} megaBase64\n     * @returns {string}\n     */\n    static megaBase64ToBinaryString(megaBase64) {\n        const base64 = MegaUtil.megaBase64ToBase64(megaBase64);\n        return Util.base64ToBinaryString(base64);\n    }\n\n    // ----------------------------------------------------------------\n\n    /**\n     * Format bytes to human readable format like it do Mega.nz\n     * {@link https://github.com/meganz/webclient/blob/8e867f2a33766872890c462e2b51561228c056a0/js/functions.js#L298}\n     *\n     * (Yeah, I have rewrote this)\n     * @see Util.bytesToSize\n     * @param {number} bytes\n     * @param {number} [decimals]\n     * @returns {string}\n     */\n    static bytesToSize(bytes, decimals) {\n        if (bytes === 0) {\n            return \"0 B\";\n        }\n        const k = 1024;\n        if (!decimals) {\n            if (bytes > Math.pow(k, 3)) {        // GB\n                decimals = 2;\n            } else if (bytes > Math.pow(k, 2)) { // MB\n                decimals = 1;\n            }\n        }\n        const sizes = [\"B\", \"KB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\", \"ZB\", \"YB\"];\n        const i = Math.floor(Math.log(bytes) / Math.log(k));\n        return (bytes / Math.pow(k, i)).toFixed(decimals) + \" \" + sizes[i];\n    }\n}\n","import {fetch} from \"megajs2/src/browser-context.js\";\nimport Util from \"megajs2/src/util.js\";\nimport MegaUtil from \"megajs2/src/mega-util.js\";\nimport {Semaphore} from \"megajs2/src/synchronization.js\";\nimport GroupedTasks from \"megajs2/src/grouped-tasks.js\";\n\nexport default class MegaApi {\n\n    static encryptedName = false; // If true, return \"████\" names instead of `null`, when no key is provided.\n\n    static apiGateway = \"https://g.api.mega.co.nz/cs\";\n    static grouped = true;\n\n    static errorRepeatCount = 5;\n    static errorRepeatDelay = 5000;\n    /**\n     * @param {function} executable - an async function to repeat if it throws an exception\n     * @param {number} count=5 - count of the repeats\n     * @param {number} delay=5000 - ms to wait before repeating\n     * @return {Promise<*>}\n     */\n    static repeatIfErrorAsync(executable, count = MegaApi.errorRepeatCount, delay = MegaApi.errorRepeatDelay) {\n        return Util.repeatIfErrorAsync(executable, count, delay);\n    }\n\n    static ssl = 2; // Is there a difference between \"1\" and \"2\" [???]\n    /**\n     * Max parallel requests count that Mega allows for API access are `63` within ~4 seconds.\n     * If you perform more than 63 connection within ~4 seconds:\n     * Fetch error (reason: write EPROTO) will happen (not a big problem, the request will be repeated)\n     *\n     * Example values: (63, 4000);   (12, 650);   (2, 0);\n     */\n    static semaphore = new Semaphore(16, 1000);\n\n    /**\n     * @extends {GroupedTasks<String, Object, Object>}\n     * @private\n     */\n    static RequestApiGrouped = class extends GroupedTasks {\n        async handle(entriesHolder) {\n            const url = entriesHolder.key;\n\n            const entries = entriesHolder.pull();\n            const payloads = [];\n            for (const entry of entries) {\n                payloads.push(entry.getValue());\n            }\n\n            const responseArray = await MegaApi.requestApiSafe(url, payloads);\n            //console.log(\"[grouped request]\", responseArray);\n\n            entries.forEach((entry, index) => {\n                entry.resolve(responseArray[index]);\n            });\n        }\n    }\n    /** @private */\n    static requestApiGrouped = new MegaApi.RequestApiGrouped();\n\n    /**\n     * @param {*} payload\n     * @param {*} [searchParams]\n     * @param {boolean} [grouped]\n     * @returns {Promise<*>} responseData\n     */\n    static async requestApi(payload, searchParams = {}, grouped = MegaApi.grouped) {\n        const _url = new URL(MegaApi.apiGateway);\n        Util.addSearchParamsToURL(_url, searchParams);\n        const url = _url.toString();\n\n        if (grouped) {\n            return MegaApi.requestApiGrouped.getResult({\n                    key: url,\n                    value: payload\n                });\n        }\n        return (await MegaApi.requestApiSafe(url, [payload]))[0];\n    }\n\n    /**\n     * Note: If you move `semaphore` inside `requestApi` or `repeatIfErrorAsync`, then in case an error\n     * the repeating request will be added at the end of queue of `semaphore`\n     * @param {string|URL} url\n     * @param {Object[]} payloads\n     * @return {Promise<*[]>}\n     * @private\n     */\n    static async requestApiSafe(url, payloads) {\n        await MegaApi.semaphore.acquire();\n        try {\n            const response = await MegaApi.repeatIfErrorAsync(_ => MegaApi.requestApiUnsafe(url, payloads));\n            return MegaApi.apiErrorHandler(response); // todo Retry if -3 exception\n        } finally { // if an exception happens more than `count` times, or the error code was returned\n            MegaApi.semaphore.release();\n        }\n    }\n\n    /**\n     * Returns an array with one item (multiple request are not implemented), or an error code (number)\n     *\n     * An exception may be thrown by `fetch`, for example, if you perform to many connections\n     * or `json()` when Mega returns an empty string (if the server returns code 500)\n     *\n     * @param {string|URL} url\n     * @param {Object[]} payloads\n     * @return {Promise<*[]>}\n     * @private\n     */\n    static async requestApiUnsafe(url, payloads) {\n        const response = await fetch(url, {\n            method: \"post\",\n            body: JSON.stringify(payloads),\n            referrerPolicy: \"strict-origin-when-cross-origin\"\n        });\n\n        if (response.status === 500) {\n            throw Error(\"ERR_ABORTED 500 (Server Too Busy)\"); // to do not parse the empty string\n        } else if (response.status !== 200) {\n            console.error(\"[response.status]\", response.status);\n        }\n\n        const text = await response.text();\n        //console.log(\"[api-response-text]\", text);\n        return JSON.parse(text);\n    }\n\n    /** @private */\n    static apiErrorHandler(response) {\n        if (Array.isArray(response)) { //todo for file links it is _in an array_\n            return response;\n        } else {\n            // todo v2 api error response\n            // todo create separate method to handle all errors\n            // https://mega.nz/doc\n            if (response === -9) {\n                throw new Error(\"ERROR CODE: -9. NOT FOUND\");\n            } else if (response === -16) {\n                throw new Error(\"ERROR CODE: -16. USER IS BLOCKED\");\n            } else if (response === -3) {\n                throw new Error(\"ERROR CODE: -3. AGAIN\");\n                //  A temporary congestion or server malfunction prevented your request from being processed.\n                //  No data was altered. Retry.\n                //  Retries must be spaced with exponential backoff. //todo\n            } else {\n                throw new Error(\"ERROR CODE: \" + response); // `response` is a number like this: `-9`\n            }\n        }\n    }\n\n    // ----------------------------------------------------------------\n\n    /**\n     * @param {FileAttribute} fileAttribute\n     * @param {string} fileAttribute.id - file attribute ID\n     * @param {number} fileAttribute.type - file attribute type\n     * @return {Promise<string>}\n     */\n    static async requestFileAttributeDownloadUrl({id, type}) {\n        console.log(\"Request download url...\");\n        const responseData = await MegaApi.requestApi({\n            \"a\": \"ufa\",    // action (command): u [???] file attribute\n            \"fah\": id,     // `h` means handler(hash, id)\n            \"ssl\": MegaApi.ssl,\n            \"r\": 1         // r [???] – It adds \".\" in response url (without this dot the url does not work)\n        });\n\n        //todo if [{\"p\":\"https://gfs302n203.userstorage.mega.co.nz/.yWdyTeW\",\"p0\":\"https://gfs270n873.userstorage.mega.co.nz/.Uy96JeV\"}]\n        return responseData[\"p\"] + \"/\" + type;\n    }\n\n\n    // todo add semaphore, not more than 31 (included) connections for each url (of bunch)\n    //  to test it, use `Thumbnail.getEncryptedBytes(..., false)` <- \"false\"\n    //  in some kind it is implemented in `FileAttributeBytes.DlBytesRequests`\n    /**\n     * @param {string} url\n     * @param {string|string[]} ids\n     * @returns {Promise<Uint8Array>} responseBytes\n     * @throws ETIMEDOUT, ECONNRESET\n     */\n    static async requestFileAttributeBytes(url, ids) {\n        /** @type Uint8Array */\n        let selectedIdsBinary;\n\n        if (Array.isArray(ids)) {\n            selectedIdsBinary = new Uint8Array(ids.length * 8);\n            for (let i = 0; i < ids.length; i++) {\n                selectedIdsBinary.set(MegaUtil.megaBase64ToArrayBuffer(ids[i]), i * 8);\n            }\n        } else {\n            selectedIdsBinary = MegaUtil.megaBase64ToArrayBuffer(ids);\n        }\n\n        /** Sometimes it can throw `connect ETIMEDOUT` or `read ECONNRESET` exception */\n        const callback = async () => {\n            console.log(\"Downloading content... \");\n            const response = await fetch(url, {\n                method: \"post\",\n                body: selectedIdsBinary,\n                headers: {\n                    // It's important for `node-fetch` (Node.js)\n                    // But it is not needed in a browser\n                    \"connection\": \"keep-alive\"\n                },\n                referrerPolicy: \"strict-origin-when-cross-origin\"\n            });\n            if (response.status !== 200) {\n                console.error(\"[response.status]\", response.status);\n            }\n            return new Uint8Array(await response.arrayBuffer());\n        };\n        const responseBytes = await MegaApi.repeatIfErrorAsync(callback);\n        console.log(\"[downloaded]\", responseBytes.length, \"bytes\");\n        return responseBytes;\n    }\n\n    // ----------------------------------------------------------------\n\n    /**\n     * @param {string} shareId\n     * @returns {Promise<{size: number, nodeAttributesEncoded: string,\n     *           downloadUrl: string, timeLeft: number, EFQ: number, MSD: number, fileAttributesStr?: string}>} nodeInfo\n     */\n    static async requestNodeInfo(shareId) {\n        const responseData = await MegaApi.requestApi({\n            \"a\": \"g\",        // Command type\n            \"p\": shareId,    // Content ID\n            \"g\": 1,          // The download link\n            //\"v\": 2,        // Multiple links for big files\n            \"ssl\": MegaApi.ssl  // HTTPS for the download link\n        });\n        //console.log(\"[responseData]\", responseData);\n\n        const prettyResponse = {\n            size:                  responseData[\"s\"],\n            nodeAttributesEncoded: responseData[\"at\"],  // Node attributes (name, hash (file fingerprint) -> mtime)\n\n            // If \"g\" is specified:\n            downloadUrl:           responseData[\"g\"],\n            timeLeft:              responseData[\"tl\"],  // Time to wait of the reset of bandwidth quota.\n                                                        // `0` seconds if quota is not exceeded\n                                                        // (It looks it is the new parameter added\n                                                        //                             at the beginning of March 2020)\n            // Useless properties: [unused]\n            EFQ:                   responseData[\"efq\"], // `1` – Something about the Quota – Quota enforcement?  [???]\n            MSD:                   responseData[\"msd\"]  // `1` – \"MegaSync download\"                             [???]\n        };\n\n        if (responseData[\"fa\"]) {\n            // File attributes (a thumbnail, a preview, [a video meta info])\n            // Only for an image or a video\n            prettyResponse.fileAttributesStr = responseData[\"fa\"];\n        }\n\n        return prettyResponse;\n    }\n\n    // The logic of nodes order that Mega returns looks like it is:\n    // The first node is root node,\n    // the next: root node children sorted by creationDate (folders have the same priority as files),\n    // the next: nodes (also sorted by creationDate) of each folder,\n    //              these folder iterates from last one to the first (like a stack works). And etc.\n    //\n    // So, a folder node is always located before the nodes that are inside it,       <-- [important]\n    // all nodes with the same parent are listed one by one in creationDate order,\n    // one level folders iterates in reverse order to `print` their children.\n    static async requestFolderInfo(shareId) {\n        const responseData = await MegaApi.requestApi({\n            \"a\": \"f\",\n            \"r\":  1, // Recursive (include sub folders/files) // if not set only root node and 1th lvl file/folder nodes\n            \"c\":  1, // [???][useless]\n            \"ca\": 1, // [???][useless]\n        }, {\n            \"n\": shareId\n        });\n        //console.log(\"[responseData]\", responseData);\n\n        const {\n            f: rawNodes, // array of file and folder nodes\n            sn, // [???][unused] // \"McPlUF51ioE\" [random]\n            noc // [???][unused] // \"1\"\n        } = responseData;\n\n\n        function _getShareRootNodeId(rawNodes) {\n            // Every node has a prefix in its `k` value – `shareRootNodeId:decryptionKey`\n            const firstNode = rawNodes[0];\n            const id = firstNode[\"k\"].match(/^[^:]+/)[0];\n\n            // In fact the first node is the share root\n            // Recheck:\n            if (id !== firstNode[\"h\"]) {\n                console.warn(\"ShareRootNodeId does not equal to id of the first node.\");\n            }\n\n            return id;\n        }\n\n        const shareRootNodeId = _getShareRootNodeId(rawNodes);\n        //console.log(\"[shareRootNodeId]\", shareRootNodeId);\n\n\n        function _prettifyType(type) {\n            switch (type) {\n                case  0: return \"file\";\n                case  1: return \"folder\";\n                default: return type;\n            }\n        }\n\n        function _parseKeyFromNode(node) {\n            const decryptionKeyStr = node[\"k\"];\n            // a missing key (an empty string), it's very rarely, but it can be\n            if (decryptionKeyStr === \"\") {\n                console.log(\"A missed key!\", node);\n                return null;\n            }\n            return decryptionKeyStr.match(/(?<=:)[\\w-_]+/)[0];\n        }\n\n        function _prettifyNodes(rawNodes) {\n            return rawNodes.map(node => {\n                const prettyNode = {\n                    id: node[\"h\"],\n                    parentId: node[\"p\"],\n                    ownerId: node[\"u\"],\n                    type: _prettifyType(node[\"t\"]),\n                    attributes: node[\"a\"],\n                    decryptionKeyStr: _parseKeyFromNode(node), // from node[\"k\"]\n                    creationDate: node[\"ts\"], // (timestamp)\n                };\n                if (prettyNode.type === \"file\") {\n                    prettyNode.size = node[\"s\"];\n                    if (node[\"fa\"]) { // only for images and videos\n                        prettyNode.fileAttributesStr = node[\"fa\"];\n                    }\n                }\n                return prettyNode;\n            });\n        }\n\n        return {nodes: _prettifyNodes(rawNodes), rootId: shareRootNodeId};\n    }\n\n}\n","/**\n * @typedef {Function} Resolve\n */\n\n/** @template K, V, R */\nclass SimpleEntry {\n    /** @type {function(Resolve): void} */\n    resolve;\n\n    /**\n     * @param {K} key - group criterion\n     * @param {V} value\n     * @param {Resolve} resolve\n     * @param {Function} reject\n     */\n    constructor(key, value, resolve, reject) {\n        this.key     = key;\n        this.value   = value;\n        this.resolve = resolve;\n        this.reject  = reject;\n    }\n\n    /** @return {K} */\n    getKey() {\n        return this.key;\n    }\n\n    /** @return {V} */\n    getValue() {\n        return this.value;\n    }\n\n    /**\n     * Override if you implement `getResult()`\n     * @default\n     * @return {boolean}\n     */\n    needHandle() {\n        return true;\n    }\n\n    /**\n     * @abstract\n     * @return {R}\n     */\n    getResult() {\n        throw \"SimpleEntry.getResult() method does not implemented\";\n    }\n}\n\n/** @template K, V, R */\nclass EntriesHolder {\n    /** @type {K} */\n    key;\n    /** @type {SimpleEntry<K, V, R>} */\n    first;\n\n    /**\n     * @param {K} entryKey\n     * @param {SimpleEntry<K, V, R>} firstEntry\n     * @param {GroupedTasks<K, V, R>} groupedTasks\n     */\n    constructor(entryKey, firstEntry, groupedTasks) {\n        this.key = entryKey;\n        this.first = firstEntry;\n        this.groupedTasks = groupedTasks;\n    }\n\n    /** @return {SimpleEntry<K, V, R>[]} */\n    pull() {\n        return this.groupedTasks.pullEntries(this.key);\n    }\n\n    /**\n     * If passed `0` - no splitting\n     * @param count\n     * @return {Generator<SimpleEntry<K, V, R>[]>}\n     */\n    parts(count) {\n        return this.groupedTasks.pullParts(this.key, count);\n    }\n}\n\n/**\n * @template K, V, R\n * @abstract\n */\nclass GroupedTasks {\n\n    /**\n     * @param {SimpleEntry<K, V, R>} entryClass\n     * @param {Function} delayStrategy\n     */\n    constructor({entryClass, delayStrategy} = {}) {\n        this.entryClass = entryClass || GroupedTasks.SimpleEntry;\n        this.delayStrategy = delayStrategy || GroupedTasks.execute.afterDelayWithMicroTask;\n    }\n\n    /**\n     * @type {Class<SimpleEntry<K, V, R>>}\n     */\n    static SimpleEntry = SimpleEntry;\n\n    /**\n     * @type Map<K, SimpleEntry<K, V, R>[]>\n     * @private\n     */\n    queue = new Map();\n\n    /**\n     * @param {Object} init\n     * @param {K?} init.key\n     * @param {V?} init.value\n     * @return {Promise<R>}\n     */\n    getResult({key, value}) {\n        return new Promise((resolve, reject) => {\n            const entry = new this.entryClass(key, value, resolve, reject);\n            if (entry.needHandle()) {\n                this.enqueue(entry);\n            } else {\n                resolve(entry.getResult());\n            }\n        });\n    }\n\n    /**\n     * @param {SimpleEntry<K, V, R>} entry\n     * @private\n     */\n    enqueue(entry) {\n        const entryKey = entry.getKey();\n        if (!this.queue.has(entryKey)) {\n            this.queue.set(entryKey, []);\n            this.delayStrategy(() => {\n                this.handle(new EntriesHolder(entryKey, entry, this))\n                    .catch(entry.reject);\n            });\n        }\n        this.queue.get(entryKey).push(entry);\n    }\n\n    /**\n     * @param {K} key\n     * @return {SimpleEntry<K, V, R>[]}\n     */\n    pullEntries(key) {\n        const array = this.queue.get(key);\n        this.queue.delete(key);\n        return array;\n    }\n\n    /**\n     * @param {K} key\n     * @param {Number} count\n     * @return {Generator<SimpleEntry<K, V, R>[]>}\n     */\n    *pullParts(key, count) {\n        const array = this.pullEntries(key);\n\n        if (!count) {\n            yield array;\n        } else {\n            let pos = 0;\n            while (pos < array.length) {\n                yield array.slice(pos, pos + count);\n                pos += count;\n            }\n        }\n    }\n\n    /**\n     * @abstract\n     * @param {EntriesHolder<K, V, R>} entriesHolder\n     * @return {Promise<void>}\n     */\n    async handle(entriesHolder) {}\n\n    /** Contains methods to delay the execution of the passed callback */\n    static execute = class {\n        static now(executable) {\n            executable();\n        }\n        static afterDelayWithMicroTask(executable){ // Delay execution with micro task queue\n            Promise.resolve().then(executable);\n        }\n        static afterDelayWithEventLoop(executable){\n            setImmediate ? setImmediate(executable) : setTimeout(executable, 0);\n        }\n        static afterDelay(executable, ms = 0){\n            setTimeout(executable, ms);\n        }\n    }\n}\n\nexport default GroupedTasks;\nexport {GroupedTasks, SimpleEntry};","import {performance} from \"./browser-context.js\";\nimport Util from \"./util.js\";\n\nexport class Semaphore {\n    /**\n     * By default works like a mutex\n     * @param {number} limit - the max count of parallel executions\n     * @param {number} time  - the time within which does not allowed to perform more than `limit` operations. (ms)\n     */\n    constructor(limit = 1, time = 0) {\n        this.limit = limit;\n        this.delay = time;\n    }\n\n    /** @type {number} - the count of active parallel executions */\n    active = 0;\n    /** @type {(function: void)[]} - resolve functions of enqueued executions */\n    pending = [];\n    /** @type {number[]} - finish times of completed executions (it's used when there is no enqueued executions) */\n    completeTimes = [];\n\n    /** @return {Promise<void>} */\n    async acquire() {\n        if (this.isDisabled) {\n            return;\n        }\n\n        const completed = this.completeTimes.length;\n        if (completed > 0 && completed === this.limit - this.active) {\n            const time = this.delay - (performance.now() - this.completeTimes.shift());\n            console.log(\"completed: \" + completed + \", active: \" + this.active + \", wait: \" + time);\n            await Util.sleep(time);\n        }\n\n        if (this.active < this.limit) {\n            this.active++;\n            return;\n        }\n\n        return new Promise(resolve => {\n            this.pending.push(resolve);\n        });\n    }\n\n    /**\n     * Recommendation: release in a finally block.\n     */\n    release() {\n        // Just do not return a Promise\n        this._release().then(/*ignore promise*/);\n    }\n\n    /** @private */\n    async _release() {\n        if (this.isDisabled) {\n            return;\n        }\n\n        if (this.active > 0) {\n            this.active--;\n\n            if (this.pending.length > 0) {\n                const resolve = this.pending.shift();\n                this.active++;\n                await Util.sleep(this.delay);\n                resolve();\n            } else if (this.delay > 0) {\n                this.completeTimes.push(performance.now());\n            }\n        } else {\n            console.warn(\"[Semaphore] over released\"); // a possible error is in a code\n        }\n    }\n\n    /**\n     * Note (It's important, in other case the semaphore will not work):\n     * When you want to limit the parallel execution count of an async function\n     * use `return` statement in the \"executable\" callback,\n     * or use `await` statement in the \"executable\" callback if you do not need the result.\n     *\n     * @example\n     * const semaphore = new Semaphore(4);\n     * for (const value of values) {\n     *      semaphore.sync(() => {\n     *          return handle(value);\n     *      }).then(console.log); // result of `handle`\n     * }\n     * @example\n     * const semaphore = new Semaphore(4);\n     * for (const value of values) {\n     *      semaphore.sync(async () => {\n     *          await handle(value);\n     *      }).then(console.log); // `undefined`\n     * }\n     *\n     * @param {function(): Promise<*>} executable\n     * @return {Promise<*>}\n     */\n    async sync(executable) {\n        try {\n            await this.acquire();\n            return await executable();\n        } finally {\n            this.release();\n        }\n    }\n\n    /**\n     * Release all waiters without any delay\n     */\n    releaseAll() {\n        while (this.pending.length) {\n            const resolve = this.pending.shift();\n            resolve();\n        }\n        this.active = 0;\n        this.completeTimes = [];\n    }\n\n    _limit;\n    _delay;\n\n    set limit(value) {\n        if (value < 1) {\n            this._limit = 1;\n        } else {\n            this._limit = value;\n        }\n    }\n\n    get limit() {\n        return this._limit;\n    }\n\n    set delay(value) {\n        if (value < 0) {\n            this._delay = 0;\n        } else {\n            this._delay = value;\n        }\n    }\n\n    get delay() {\n        return this._delay;\n    }\n\n    isDisabled = false;\n\n    disable(releaseAll = true) {\n        if (releaseAll) {\n            this.releaseAll();\n        }\n        this.isDisabled = true;\n    }\n\n    enable() {\n        this.isDisabled = false;\n    }\n\n    /**\n     * Static factory method, works as constructor.\n     * Returns the disabled semaphore.\n     * Pass it to a code that expect a semaphore, but you do not need it.\n     */\n    static disabled(max = 1, delay = 0) {\n        const semaphore = new Semaphore(max, delay);\n        semaphore.disable();\n        return semaphore;\n    }\n}\n\nexport class CountDownLatch {\n    _count;\n    _promise;\n    _resolve;\n\n    /** @param {number} count */\n    constructor(count = 0) {\n        this._count = count;\n        if (count > 0) {\n            this._promise = new Promise(resolve => {\n                this._resolve = resolve;\n            });\n        } else {\n            this._promise = Promise.resolve();\n        }\n    }\n\n    countDown() {\n        if (this._count > 0) {\n            this._count--;\n            if (this._count === 0) {\n                this._resolve();\n            }\n        }\n    }\n\n    /** @return {Promise<void>} */\n    wait() {\n        return this._promise;\n    }\n\n    /** @return {boolean} */\n    get released() {\n        return this._count > 0;\n    }\n\n    release() {\n        this._count = 0;\n        this._resolve();\n    }\n}\n\nexport class CountUpAndDownLatch extends CountDownLatch {\n    countUp() {\n        if (this._count === 0) {\n            this._promise = new Promise(resolve => {\n                this._resolve = resolve;\n            });\n        }\n        this._count++;\n    }\n}\n\nexport default {Semaphore, CountDownLatch, CountUpAndDownLatch};","import Util from \"./util.js\";\nimport Crypto from \"./crypto.js\";\nimport MegaUtil from \"./mega-util.js\";\nimport MegaApi from \"./mega-api.js\";\nimport GroupedTasks from \"./grouped-tasks.js\";\nimport {Semaphore} from \"./synchronization.js\";\n\n/**\n * The interface of a media file node\n * @typedef {{fileAttributesStr: string, key?: Uint8Array}} IMediaNodeSimple\n */\n\n/**\n * @typedef IMediaGettersMixin\n * @property {FileAttribute} thumbnail\n * @property {FileAttribute} preview\n * @property {function(): Promise<Uint8Array>} getThumbnail\n * @property {function(): Promise<Uint8Array>} getPreview\n */\n\n/**\n * @typedef {IMediaNodeSimple & IMediaGettersMixin} IMediaNode\n */\n\n/**\n *\n */\nclass FileAttribute {\n    /** @type {string} */\n    id;\n    /** @type {number} */\n    type;\n    /** @type {Bunch} */\n    bunch;\n\n    /**\n     * @param {string} id - `id`, or `handler` as Mega names it\n     * @param {number|*} type - 0 – thumbnail, 1 - preview, 8 - ..., 9 - ...\n     * @param {number|*} bunch - Attributes with the same bunch number can be requested within one API request\n     */\n    constructor(id, type, bunch) {\n        this.id = id;\n        this.type = Number(type);\n        this.bunch = Bunch.of(Number(bunch));\n    }\n\n    /**\n     * @param {boolean} cached=true\n     * @return {Promise<string>}\n     */\n    getDownloadUrl(cached = true) {\n        if (!Types.hasBytes(this)){\n            return null;\n        }\n        return this.bunch.getDownloadUrl(this, cached);\n    }\n\n    toString() {\n        return this.bunch + \":\" + this.type + \"*\" + this.id;\n    }\n}\n\nclass Bunch {\n    /** @type {Number} */\n    id;\n\n    downloadUrl = null;\n\n    /**\n     * The holder of the instances of this class.\n     * @private\n     * @type {Map<number, Bunch>}\n     */\n    static values = new Map();\n\n    /**\n     * Use `of` method to get an instance.\n     * @private\n     * @param {number} bunch\n     */\n    constructor(bunch) {\n        this.id = Number(bunch);\n    }\n\n    toString() {\n        return this.id.toString();\n    }\n\n    /**\n     * @param {number} bunch\n     * @return {Bunch}\n     */\n    static of(bunch) {\n        if (Bunch.values.has(bunch)) {\n            return Bunch.values.get(bunch);\n        }\n        const _bunch = new Bunch(bunch);\n        Bunch.values.set(bunch, _bunch);\n        return _bunch;\n    }\n\n    /**\n     * @param {FileAttribute} fileAttribute\n     * @param {boolean} cached=true\n     * @return {Promise<string>}\n     */\n    async getDownloadUrl(fileAttribute, cached = true) {\n        if (cached && this.hasDownloadUrl) {\n            return this.downloadUrl;\n        }\n        const url = await MegaApi.requestFileAttributeDownloadUrl(fileAttribute);\n        //todo urls\n        this.downloadUrl = url;\n        return url;\n    }\n    get hasDownloadUrl() {\n        return Boolean(this.downloadUrl);\n    }\n    get downloadUrl() {\n        return this.downloadUrl;\n    }\n}\n\nclass Types {\n    static thumbnail = 0;\n    static preview   = 1;\n\n    /**\n     * @param {FileAttribute} fileAttribute\n     * @return {boolean}\n     */\n    static hasBytes(fileAttribute) {\n        return fileAttribute.type === Types.preview || fileAttribute.type === Types.thumbnail;\n    }\n}\n\nexport class FileAttributeBytes {\n    static cached = true;\n    static grouped = true\n\n    /** @type {number} */ //todo use Types?\n    type;\n\n    get type() {\n        return this.type;\n    }\n\n    constructor(type) {\n        this.type = type;\n    }\n\n    /**\n     * @extends {GroupedTasks<Number, FileAttribute, String>}\n     */\n    static DlUrlRequests = class extends GroupedTasks {\n        async handle(entriesHolder) {\n            const fileAttribute = entriesHolder.first.getValue();\n            const result = await fileAttribute.getDownloadUrl();\n\n            for (const entry of entriesHolder.pull()) {\n                entry.resolve(result);\n            }\n        }\n\n        /** @type {Class<!GroupedTasks.SimpleEntry<Number, FileAttribute, String>>} */\n        static RequestDlUrlEntry = class extends GroupedTasks.SimpleEntry {\n            /** @return {boolean} */\n            needHandle() {\n                return !this.getValue().bunch.hasDownloadUrl;\n            }\n            /** @return {String} */\n            getResult() {\n                return this.getValue().bunch.downloadUrl;\n            }\n            /** @return {number} */\n            getKey() {\n                return this.getValue().bunch.id;\n            }\n        }\n    }\n    static dlUrlRequests = new FileAttributeBytes.DlUrlRequests({\n        entryClass: FileAttributeBytes.DlUrlRequests.RequestDlUrlEntry,\n        delayStrategy: GroupedTasks.execute.now\n    });\n\n    /**\n     * @param options\n     * @param {FileAttribute} [options.fileAttribute]\n     * @param {IMediaNode} [options.node]\n     * @param {boolean} cached=true - do not request the new URL, if already there is one, experimental use only\n     * @return {Promise<string>} downloadUrl\n     */\n    getDownloadUrl({fileAttribute, node}, cached = FileAttributeBytes.cached) {\n        const _fileAttribute = fileAttribute || FileAttributes.of(node).byType(this.type);\n        if (cached) {\n            return FileAttributeBytes.dlUrlRequests.getResult({\n                    value: _fileAttribute\n                });\n        }\n        return _fileAttribute.getDownloadUrl(false);\n    }\n\n    /**\n     * Split a grouped request (of file attribute bytes) to grouped requests of 16 requests in each.\n     * Up to 16 parallel downloading for a chunk.\n     * @extends {GroupedTasks<String, String, Uint8Array>}\n     */\n    static DlBytesRequests = class extends GroupedTasks {\n        async handle(entriesHolder) {\n            const downloadUrl = entriesHolder.key;\n\n            const semaphore = new Semaphore(16); // do not use more than 31\n            for (const entries of entriesHolder.parts(16)) { // use `0` to disable splitting\n                semaphore.sync(() => {\n                    return this.handlePart(downloadUrl, entries);\n                }).then(/*ignore promise*/);\n            }\n        }\n\n        /** @private */\n        async handlePart(downloadUrl, entries) {\n            /**\n             * Maps fileAttributeId to resolves\n             * (different nodes may have the same file attribute)\n             * @type {Map<string, Resolve[]>}\n             */\n            const map = new Map();\n\n            for (const entry of entries) {\n                const fileAttributeId = entry.getValue();\n                if (!map.has(fileAttributeId)) {\n                    map.set(fileAttributeId, []);\n                }\n                map.get(fileAttributeId).push(entry.resolve);\n            }\n\n            const fileAttrIDs = [...map.keys()];\n            const generator = FileAttributeBytes.fileAttributeBytes(downloadUrl, fileAttrIDs);\n            for await (const {id, dataBytes} of generator) {\n                const resolvers = map.get(id);\n                for (const resolve of resolvers) {\n                    resolve(dataBytes);\n                }\n            }\n        }\n    }\n    static dlBytesRequests = new FileAttributeBytes.DlBytesRequests();\n\n    /**\n     * @param options\n     * @param {FileAttribute} [options.fileAttribute]\n     * @param {string} [options.downloadUrl]\n     * @param {IMediaNode} [options.node]\n     * @param {boolean} grouped=true - with `false` it may work a bit faster, but extremely increases\n     * the connection count – one per each file attribute, currently there is no limitation of connection count\n     * in the code (a semaphore), but Mega handles 136 connections at one moment normally\n     * @return {Promise<Uint8Array>} encryptedBytes\n     */\n    async getEncryptedBytes({fileAttribute, downloadUrl, node}, grouped = FileAttributeBytes.grouped) {\n        const _fileAttribute = fileAttribute || FileAttributes.of(node).byType(this.type);\n        const _downloadUrl = downloadUrl || await this.getDownloadUrl({fileAttribute: _fileAttribute});\n\n        if (grouped) {\n            return FileAttributeBytes.dlBytesRequests.getResult({\n                key: _downloadUrl,\n                value: _fileAttribute.id\n            });\n        }\n\n        const responseBytes = await MegaApi.requestFileAttributeBytes(_downloadUrl, _fileAttribute.id);\n        return FileAttributeBytes.parseBytes(responseBytes).dataBytes;\n    }\n\n    /**\n     * @param {string} downloadUrl\n     * @param {string[]} fileAttrIDs\n     * @return {AsyncGenerator<{dataBytes: Uint8Array, id: string}>}\n     */\n    static async *fileAttributeBytes(downloadUrl, fileAttrIDs) {\n        const responseBytes = await MegaApi.requestFileAttributeBytes(downloadUrl, fileAttrIDs);\n\n        for (let i = 0, offset = 0; i < fileAttrIDs.length; i++) {\n            const {id, dataBytes} = FileAttributeBytes.parseBytes(responseBytes, offset);\n            yield {id, dataBytes};\n            offset += 12 + dataBytes.length;\n        }\n    }\n\n    /** @private */\n    static parseBytes(bytes, offset = 0) {\n        const idBytes     = bytes.subarray(offset,      offset +  8);\n        const lengthBytes = bytes.subarray(offset + 8,  offset + 12);\n        const length      = Util.arrayBufferToLong(lengthBytes);\n        const dataBytes   = bytes.subarray(offset + 12, offset + 12 + length);\n        const id          = MegaUtil.arrayBufferToMegaBase64(idBytes);\n        return {id, dataBytes};\n    }\n\n    /**\n     * @param options\n     * @param {FileAttributes} [options.fileAttributes]\n     * @param {Uint8Array} [options.encryptedBytes]\n     * @param {IMediaNode} [options.node]\n     * @param {string} [options.downloadUrl]\n     * @return {Promise<Uint8Array>}\n     */\n    async getBytes({fileAttributes, encryptedBytes, node, downloadUrl}) {\n        const _fileAttributes = fileAttributes || FileAttributes.of(node);\n        const fileAttribute = _fileAttributes.byType(this.type);\n        const _encryptedBytes = encryptedBytes || await this.getEncryptedBytes({fileAttribute, downloadUrl, node});\n\n        if (!_fileAttributes.nodeKey) {\n            if (FileAttributes.strictMode) {\n                throw \"No key specified for the file attribute decryption.\";\n            } else {\n                console.log(\"No key specified for the file attribute decryption. Skipping the decryption.\");\n                return _encryptedBytes;\n            }\n        }\n        console.log(\"Decryption of a file attribute...\");\n        return Crypto.decryptAES(_encryptedBytes, _fileAttributes.nodeKey, {padding: \"ZeroPadding\"});\n    }\n}\n\nexport default class FileAttributes {\n\n    /**\n     * If `false` (default) returns not decrypted file attribute if no node key specified.\n     * If `true` `FileAttributes.getBytes` will throw the exception.\n     *\n     * @type {boolean}\n     */\n    static strictMode = false;\n\n    /** @type {FileAttribute[]} */\n    fileAttributes;\n    /** @type {Uint8Array} */\n    nodeKey;\n\n    constructor(node) {\n        const fileAttributes = [];\n\n        const chunks = node.fileAttributesStr.split(\"\\/\");\n        chunks.forEach(chunk => {\n            const groups = chunk.match(/(?<bunch>\\d+):(?<type>\\d+)\\*(?<id>.+)/).groups;\n            const {id, type, bunch} = groups;\n            fileAttributes.push(new FileAttribute(id, type, bunch));\n        });\n\n        this.fileAttributes = fileAttributes;\n        this.nodeKey = node.key || null;\n    }\n\n    /** Example output: \"924:1*sqbpWSbonCU/925:0*lH0B2ump-G8\" */\n    toString() {\n        return this.fileAttributes.join(\"/\");\n    }\n\n    /**\n     * Get file attribute by type (0, 1, 8, or 9)\n     * @param {number} type\n     * @return {FileAttribute}\n     */\n    byType(type) {\n        return this.fileAttributes.find(att => att.type === type);\n    }\n\n    // ========\n\n    /** @type {Map<String, FileAttributes>} */\n    static values = new Map();\n\n    /**\n     * @param {IMediaNode} node\n     */\n    static add(node) {\n        if (!FileAttributes.values.get(node.fileAttributesStr)) {\n            FileAttributes.values.set(node.fileAttributesStr, new FileAttributes(node));\n        }\n    }\n\n    /**\n     * @param {IMediaNode} node\n     * @return {FileAttributes}\n     */\n    static get(node) {\n        return FileAttributes.values.get(node.fileAttributesStr);\n    }\n\n    /**\n     * @param {IMediaNode} node\n     * @return {FileAttributes}\n     */\n    static of(node) {\n        FileAttributes.add(node);\n        return FileAttributes.get(node);\n    }\n\n    // ========\n\n    /** Like a static class, but with polymorphism */\n    static Thumbnail = new FileAttributeBytes(Types.thumbnail);\n    static Preview   = new FileAttributeBytes(Types.preview);\n\n    /**\n     * @param {IMediaNode} node\n     * @return {Promise<Uint8Array>}\n     */\n    static getThumbnail(node) {\n        return FileAttributes.getAttribute(node, FileAttributes.Thumbnail);\n    }\n    /**\n     * @param {IMediaNode} node\n     * @return {Promise<Uint8Array>}\n     */\n    static getPreview(node) {\n        return FileAttributes.getAttribute(node, FileAttributes.Preview);\n    }\n\n    /**\n     * NB: can be not only JPG (FF D8 FF (E0)), but PNG (89 50 4E 47 0D 0A 1A 0A) too, for example.\n     * https://en.wikipedia.org/wiki/List_of_file_signatures\n     *\n     * @param {IMediaNode} node\n     * @param {FileAttributeBytes} typeClass\n     * @return {Promise<Uint8Array>}\n     */\n    static getAttribute(node, typeClass) {\n        return typeClass.getBytes({node});\n    }\n\n}","/**\n * This class represents the share,\n * the information that is needed to get the access to a shared content – a folder, or a file.\n *\n * Usually you have the URL, that contains that data.\n * `Share.fromUrl(url)` parses the URL and returns the instance of this class.\n */\nexport default class Share {\n    /** @type {string} */\n    id;\n    /** @type {string} */\n    decryptionKeyStr;\n    /** @type {boolean} */\n    isFolder;\n    /** @type {string} */\n    selectedFolderId;\n    /** @type {string} */\n    selectedFileId;\n\n    /**\n     * @private\n     * @param {{\n     *    id: string,\n     *    decryptionKeyStr?: string,\n     *    isFolder?: boolean,\n     *    selectedFolderId?: string,\n     *    selectedFileId?: string\n     *  }} shareParts\n     */\n    constructor(shareParts) {\n        Object.assign(this, shareParts);\n    }\n\n    /** @return {string} */\n    toString() {\n        return \"\" +\n            \"[id]               \" + this.id               + \"\\n\" +\n            \"[decryptionKeyStr] \" + this.decryptionKeyStr + \"\\n\" +\n            \"[isFolder]         \" + this.isFolder         + \"\\n\" +\n            \"[selectedFolderId] \" + this.selectedFolderId + \"\\n\" +\n            \"[selectedFileId]   \" + this.selectedFileId   + \"\\n\" +\n            \"[url]              \" + this.getUrl()         + \"\\n\" +\n            \"[url-legacy]       \" + this.getUrl(true);\n    }\n\n    /**\n     * @param {string|URL} url - URL\n     * @return {boolean}\n     */\n    static isFolder(url) {\n        return Share.fromUrl(url).isFolder;\n    }\n\n    /** @return {string} */\n    get selectedId() {\n        return this.selectedFileId || this.selectedFolderId || null;\n    }\n\n    //todo? create a singleton/caching for at least one last url? to do not parse several times the same url.\n    /**\n     * @see URLS\n     * @param {string|URL} url - URL\n     * @returns {Share}\n     */\n    static fromUrl(url) {\n        const _url = url.toString(); // if passed a URL object\n        const isLegacyURL = /#F!|#!/;\n        let regExp;\n\n        if (_url.match(isLegacyURL)) {\n            regExp = /(?<type>(?<isFolder>#F!)|(?<isFile>#!))(?<id>[\\w-_]+)(?<keyPrefix>!(?=[\\w-_]{22,43})|!(?=[!?])|!(?![\\w-_]{8}))?(?<key>(?<=!)[\\w-_]{22,43})?(?<selected>((?<selectedFilePrefix>\\?)|(?<selectedFolderPrefix>!?))((?<file>(?<=\\?)[\\w-_]+)|(?<folder>(?<=!)[\\w-_]+)))?/;\n        } else {\n            regExp = /(?<type>(?<isFolder>folder\\/)|(?<isFile>file\\/))(?<id>[\\w-_]+)(?<keyPrefix>#)?(?<key>(?<=#)[\\w-_]{22,43})?(?<selected>((?<selectedFilePrefix>\\/file\\/)|(?<selectedFolderPrefix>\\/folder\\/))((?<file>(?<=\\/file\\/)[\\w-_]+)|(?<folder>(?<=\\/folder\\/)[\\w-_]+)))?/;\n        }\n\n        const match = _url.match(regExp);\n        if (!match) {\n            throw `Unsupported URL (\"${_url}\")`;\n        }\n        const {groups} = match;\n\n        const isFolder = Boolean(groups.isFolder);\n        /** Content ID */\n        const id = groups.id;\n        /** Decryption key encoded with Mega's base64 */\n        const decryptionKeyStr = groups.key    || \"\";\n        const selectedFolderId = groups.folder || \"\";\n        const selectedFileId   = groups.file   || \"\";\n\n        return new Share({id, decryptionKeyStr, isFolder, selectedFolderId, selectedFileId});\n    }\n\n    /**\n     * @param shareParts\n     * @param {string}   shareParts.id\n     * @param {string}  [shareParts.decryptionKeyStr=\"\"]\n     * @param {boolean} [shareParts.isFolder=false]\n     * @param {string}  [shareParts.selectedFolderId=\"\"]\n     * @param {string}  [shareParts.selectedFileId=\"\"]\n     * @return {Share}\n     */\n    static fromParts({id, decryptionKeyStr = \"\", isFolder = false, selectedFolderId = \"\", selectedFileId = \"\"}) {\n        return new Share({id, decryptionKeyStr, isFolder, selectedFolderId, selectedFileId});\n    }\n\n    /**\n     * Returns the url string for a share.\n     * I prefer to use the key separator when there is no key, but there is a selected node.\n     * Note: `Share.fromUrl(url).getUrl()` may not be equal to `url` (even for the same format)\n     *\n     * @see URLS\n     * @param {boolean} oldFormat\n     * @returns {string}\n     */\n    getUrl(oldFormat = false) {\n        let result;\n        const prefixes = {\n            folder:    oldFormat ? \"#F\" : \"folder\",\n            file:      oldFormat ? \"#\"  : \"file\",\n            id:        oldFormat ? \"!\"  : \"/\",\n            key:       oldFormat ? \"!\"  : \"#\",\n            selFile:   oldFormat ? \"?\"  : \"/file/\",\n            selFolder: oldFormat ? \"!\"  : \"/folder/\",\n        };\n\n        let selected = \"\";\n        if (this.selectedFileId) {\n            selected = prefixes.selFile + this.selectedFileId;\n        } else if (this.selectedFolderId) {\n            selected = prefixes.selFolder + this.selectedFolderId;\n        }\n\n        result = \"https://mega.nz/\" +\n            (this.isFolder ? prefixes.folder : prefixes.file) +\n            prefixes.id + this.id +\n            (this.decryptionKeyStr ? prefixes.key + this.decryptionKeyStr : \"\") +\n            (selected && !this.decryptionKeyStr ? prefixes.key + selected : selected);\n\n        return result;\n    }\n}","import Util from \"./util.js\";\nimport MegaUtil from \"./mega-util.js\";\nimport MegaApi from \"./mega-api.js\";\nimport FileAttributes from \"./file-attributes.js\";\nimport Share from \"./share.js\";\n\n\n//todo the most basic class with [Symbol.toStringTag]: \"MegaNode\"\n\nclass BasicFolderShareNode {\n    [Symbol.toStringTag] = \"BasicFolderShareNode\";\n    constructor(node, masterKey) {\n        this.id           = node.id;\n        this.parentId     = node.parentId;\n        this.parent       = node.parent || null;\n        this.ownerId      = node.ownerId;\n        this.creationDate = node.creationDate;\n\n        if (masterKey && node.decryptionKeyStr) {\n            const decryptionKeyEncrypted = MegaUtil.megaBase64ToArrayBuffer(node.decryptionKeyStr);\n            this._decryptionKey = MegaUtil.decryptKey(decryptionKeyEncrypted, masterKey);\n        } else {\n            this._decryptionKey = null;\n        }\n    }\n    type;\n    id;\n    parentId;\n    parent;\n    ownerId;\n    creationDate;\n    _decryptionKey;\n\n    get key() {\n        return this._decryptionKey;\n    };\n    name; // [requires key]\n\n    /**\n     * Returns the array of parents names from the root node\n     * @return {string[]}\n     */\n    get path() {\n        if (this.parent) {\n            return [...this.parent.path, this.parent.name];\n        }\n        return [];\n    }\n\n    /** @return {RootFolderNode} */\n    get root() {\n        return this.parent.type === \"rootFolder\" ? this.parent : this.parent.root;\n    }\n}\n\nclass FileNode extends BasicFolderShareNode {\n    [Symbol.toStringTag] = \"FileNode\";\n    constructor(node, masterKey) {\n        super(node, masterKey);\n        this.type = \"file\";\n        this.size = node.size;\n\n        if (masterKey && node.decryptionKeyStr) {\n            const {\n                name,\n                serializedFingerprint\n            } = MegaUtil.parseEncodedNodeAttributes(node.attributes, this.key);\n            this.name = name;\n\n            const {\n                modificationDate,\n                fileChecksum      // [unused][???]\n            } = MegaUtil.parseFingerprint(serializedFingerprint);\n            this.modificationDate = modificationDate;\n        } else {\n            this.modificationDate = null;\n            this.name = getEncryptedName(node.attributes, true);\n        }\n    }\n    size;\n\n    _keyParts;\n    get key() {\n        if (!this._keyParts) {\n            if (super.key) {\n                this._keyParts = MegaUtil.decryptionKeyToParts(super.key);\n            } else {\n                this._keyParts = {iv: null, metaMac: null, key: null};\n            }\n        }\n        return this._keyParts.key;\n    };\n    modificationDate;   // [requires key]\n    get mtime() {       // An alias\n        return this.modificationDate;\n    }\n    get modificationDateFormatted() {\n        return Util.secondsToFormattedString(this.modificationDate);\n    }\n\n    get downloadUrl() { // not implemented\n        return null;\n    }\n}\n\n/**\n * @implements IMediaNodeSimple\n * @mixes IMediaGettersMixin\n */\n// todo: add file attribute support for 8, 9 (9 may not exists)\nclass MediaFileNode extends FileNode {\n    [Symbol.toStringTag] = \"MediaFileNode\";\n    constructor(node, masterKey) {\n        super(node, masterKey);\n        this.type = \"mediaFile\";\n        this.fileAttributesStr = node.fileAttributesStr;\n    }\n    fileAttributesStr; // [requires key]\n\n    //todo mixin for it\n    /** @returns {Promise<Uint8Array>} */\n    getThumbnail() {\n        return FileAttributes.getThumbnail(this);\n    };\n    /** @returns {Promise<Uint8Array>} */\n    getPreview() {\n        return FileAttributes.getPreview(this);\n    };\n\n    get thumbnail() { // todo others\n        return FileAttributes.of(this).byType(FileAttributes.Thumbnail.type);\n    }\n\n    get preview() {\n        return FileAttributes.of(this).byType(FileAttributes.Preview.type);\n    }\n}\n\nclass FolderNode extends BasicFolderShareNode {\n    [Symbol.toStringTag] = \"FolderNode\";\n    constructor(node, masterKey) {\n        super(node, masterKey);\n        this.type = \"folder\";\n\n        if (masterKey) {\n            const {\n                name\n            } = MegaUtil.parseEncodedNodeAttributes(node.attributes, this.key);\n            this.name = name;\n        } else {\n            this.name = getEncryptedName(node.attributes, false);\n        }\n    }\n    folders = [];\n    files = [];\n\n    _size = 0;\n    get size() {\n        return this._size; // todo: recursive calculate the size\n    };\n}\n\nclass RootFolderNode extends FolderNode {\n    get [Symbol.toStringTag]() { return \"RootFolderNode\"; };\n    constructor(node, masterKey) {\n        super(node, masterKey);\n        this.type = \"rootFolder\";\n    }\n    /** @return {RootFolderNode} */\n    get root() {\n        return this;\n    }\n}\n\n\nclass SharedFileNode {\n    [Symbol.toStringTag] = \"SharedFileNode\";\n    constructor(share, nodeInfo) {\n        this.type = \"sharedFile\";\n        this.id = share.id; // in fact it is not real file node id (for every new generated share url you get new id)\n\n        if (share.decryptionKeyStr) {\n            const decryptionKey = MegaUtil.megaBase64ToArrayBuffer(share.decryptionKeyStr);\n            const {\n                iv,      // [unused][???] // probably it is needed for decryption (not implemented)\n                metaMac, // [unused][???]\n                key\n            } = MegaUtil.decryptionKeyToParts(decryptionKey);\n            this.key = key;\n        } else {\n            this.key = null;\n        }\n\n        const {\n            size,\n            nodeAttributesEncoded,\n            downloadUrl,\n            timeLeft,\n        } = nodeInfo;\n\n        this.size = size;\n        this._meta = {downloadUrl, timeLeft};\n\n        if (share.decryptionKeyStr) {\n            const {\n                name,\n                serializedFingerprint\n            } = MegaUtil.parseEncodedNodeAttributes(nodeAttributesEncoded, this.key);\n\n            const {\n                modificationDate,\n                fileChecksum   // [unused][???]\n            } = serializedFingerprint ? MegaUtil.parseFingerprint(serializedFingerprint) : {}; // Removed in ~2022?\n\n            this.name = name;\n            this.modificationDate = modificationDate;\n        } else {\n            this.modificationDate = null;\n            this.name = getEncryptedName(nodeAttributesEncoded, false);\n        }\n\n    }\n\n\n    type;\n    id;\n    size;\n\n    key;\n    name;\n    modificationDate;\n    get mtime() { // An alias\n        return this.modificationDate;\n    }\n    get modificationDateFormatted() {\n        return Util.secondsToFormattedString(this.modificationDate);\n    }\n\n    _meta;\n    get timeLeft() {\n        return this._meta.timeLeft;\n    }\n    get downloadUrl() {\n        return this._meta.downloadUrl;\n    }\n}\n\nclass SharedMediaFileNode extends SharedFileNode {\n    [Symbol.toStringTag] = \"SharedMediaFileNode\";\n    constructor(share, nodeInfo) {\n        super(share, nodeInfo);\n        this.type = \"sharedMediaFile\";\n        this.fileAttributesStr = nodeInfo.fileAttributesStr;\n    }\n    fileAttributesStr;\n\n    //todo mixin for it\n    /** @returns {Promise<Uint8Array>} */\n    getThumbnail() {\n        return FileAttributes.getThumbnail(this);\n    };\n    /** @returns {Promise<Uint8Array>} */\n    getPreview() {\n        return FileAttributes.getPreview(this);\n    };\n}\n\n\n\n/**\n * Static factory methods for node creating\n *\n * Well, not the best JSDoc signatures, may be rework it later\n */\nclass Nodes {\n\n    /**\n     * @param {string|URL} url\n     * @returns {Promise<SharedFileNode|SharedMediaFileNode|RootFolderNode|FolderNode|FileNode|MediaFileNode>\n     *     |Promise<(SharedFileNode|SharedMediaFileNode)[]|(RootFolderNode,FolderNode,FileNode,MediaFileNode)[]>}\n     */\n    static async of(url) {\n        const share = Share.fromUrl(url);\n        return share.isFolder ? Nodes.getFolderNodes(share) : Nodes.getSharedNode(share);\n    }\n\n    /**\n     * @param {string|URL} url\n     * @returns {Promise<SharedFileNode|SharedMediaFileNode|RootFolderNode|FolderNode|FileNode|MediaFileNode>}\n     */\n    static async node(url) {\n        const share = Share.fromUrl(url);\n        if (share.isFolder) {\n            const nodes = await Nodes.getFolderNodes(share);\n            if (nodes.selected) {\n                return nodes.selected;\n            } else {\n                return nodes.root;\n            }\n        } else {\n            return Nodes.getSharedNode(share);\n        }\n    }\n\n    /**\n     * @param {string|URL} url\n     * @returns {Promise<(SharedFileNode|SharedMediaFileNode)[]|(RootFolderNode,FolderNode,FileNode,MediaFileNode)[]>}\n     */\n    static async nodes(url) {\n        const share = Share.fromUrl(url);\n        if (share.isFolder) {\n            return Nodes.getFolderNodes(share);\n        } else {\n            return [await Nodes.getSharedNode(share)];\n        }\n    }\n\n    /**\n     * @param {Share} share\n     * @returns {Promise<SharedFileNode|SharedMediaFileNode>}\n     */\n    static async getSharedNode(share) {\n        const nodeInfo = await MegaApi.requestNodeInfo(share.id);\n        if (nodeInfo.fileAttributesStr) {\n            return new SharedMediaFileNode(share, nodeInfo);\n        } else {\n            return new SharedFileNode(share, nodeInfo);\n        }\n    }\n\n    /**\n     * @param {Share} share\n     * @returns {Promise<(RootFolderNode,FolderNode,FileNode,MediaFileNode)[]>} [note] The array have mixed type content\n     */\n    static async getFolderNodes(share) {\n\n        const masterKey = share.decryptionKeyStr ? MegaUtil.megaBase64ToArrayBuffer(share.decryptionKeyStr) : null;\n        //logger.debug(\"[masterKey]\", masterKey);\n\n        const {\n            nodes,\n            rootId\n        } = await MegaApi.requestFolderInfo(share.id);\n        //logger.debug(`[requestFolderInfo(\"${share.id}\").nodes]`, nodes);\n\n        const folders = new Map(); // [note] JS's HashMap holds the insert order\n        const files = [];\n\n\n        // `masterKey` is null when the share has no specified key,\n        // `node.decryptionKeyStr` is null when `k` of node info (from API) is an empty string (Mega's bug)\n        //todo either handle it here (new classes for nodes without a key)\n        // or in the node constructor modify its type to indicate this thing\n        for (let i = 0; i < nodes.length; i++) {\n\n            const node = nodes[i];\n            let resultNode;\n\n            node.parent = folders.get(node.parentId); // `undefine` for root\n\n            if (node.type === \"file\") {\n                if (node.fileAttributesStr) {\n                    resultNode = new MediaFileNode(node, masterKey);\n                } else {\n                    resultNode = new FileNode(node, masterKey);\n                }\n                files.push(resultNode);\n\n                // the parent node is always located before the child node, no need to check its existence [1][note]\n                folders.get(resultNode.parentId).files.push(resultNode);\n\n            } else if (node.type === \"folder\") {\n                if (node.id === rootId) { // or `if (i === 0)`\n                    resultNode = new RootFolderNode(node, masterKey);\n                } else {\n                    resultNode = new FolderNode(node, masterKey);\n                    folders.get(resultNode.parentId).folders.push(resultNode); // see [1] note\n                }\n                folders.set(node.id, resultNode);\n            }\n\n            nodes[i] = null;\n        }\n\n        // todo: rework – make an iterable class with these getters\n        const resultArray = [...folders.values(), ...files];\n        const root = folders.get(rootId);\n        const selected = resultArray.find(node => node.id === share.selectedId);\n        Object.defineProperty(resultArray, \"root\",     { get: () => root });\n        Object.defineProperty(resultArray, \"selected\", { get: () => selected });\n        Object.defineProperty(resultArray, \"folders\",  { get: () => [...folders.values()] });\n        Object.defineProperty(resultArray, \"files\",    { get: () => files });\n        //todo .mediaNodes\n\n        return resultArray;\n    }\n\n    static isMediaNode(node) {\n        return node.type === \"sharedMediaFile\" || node.type === \"mediaFile\";\n    }\n}\n\nexport default Nodes;\nexport {\n    FolderNode, RootFolderNode,\n    FileNode, MediaFileNode,\n    SharedFileNode, SharedMediaFileNode,\n    Nodes\n};\n\n/** @return {string|null} */\nfunction getEncryptedName(attributesEncoded, hasSerializedFingerprint) {\n    if (!MegaApi.encryptedName) {\n        return null;\n    }\n    // 3/4 since it's Base64; `MEGA{\"c\":\"\",\"n\":\"\"}`.length === 19; also it has padding;\n    let count = Math.trunc(attributesEncoded.length * 3/4) - 19;\n    if (hasSerializedFingerprint) {\n        count = count - 28;\n    }\n    count = count - 1; // make dividable by 4\n    if (count < 0) {\n        count = 16;\n    }\n    console.log(count);\n    return \"█\".repeat(count); // \"\\u2588\"\n}\n","import {Nodes} from \"./nodes.js\";\nexport const nodes = Nodes.nodes;\nexport const node  = Nodes.node;\n\n\nexport {default as FileAttributes, FileAttributeBytes} from \"./file-attributes.js\";\n// export {default as Crypto} from \"./crypto.js\";\n// export {default as GroupedTasks} from \"./grouped-tasks.js\";\nexport {default as MegaApi} from \"./mega-api.js\";\nexport {default as MegaUtil} from \"./mega-util.js\";\nexport {default as Nodes} from \"./nodes.js\";\nexport {default as Share} from \"./share.js\";\nexport * as Synchronization from \"./synchronization.js\";\nexport {default as Util} from \"./util.js\";"]}